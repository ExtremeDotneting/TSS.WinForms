const Куб \ int \ найменьшая частица в мире

Данные о клетке
	Характеристики
		Размер \ int \ 1 (Куб)
		Сила \ int \ 2
		Скорость \ int \ 2 (Куб)
		Восприятие \ int \ 5 (Куб)
		Желание_размножатся \ int \ 1
		Максимальный_запас_энергии \ int \ Размер*100
		Голод \ int \ 1
		Каннибализм \ int \ 1
		Агрессия \ int \ 0
		Пугливость \ int \ 0
		Максимальный_возраст \ int \ 2 //определяет сколько сотен тиков может жить клетка не поделившись (не может падать ниже 1).
	
		const Индекс_генов \ int \ не меняется при смене поколений, наследуется от первой клетки. Определяет цвет клетки.

	Состояния
		Уровень_энергии \ int \ Максимальный_запас_энергии/2
		Канибализм \ bool \ => 
			Вражески воспринемает клетки с таким же Индекс_генов, если (Уровень_энергии <= Каннибализм*100).
		Возраст \ int \ 1


	Физическое положение
		x0 \ int \ (Куб)
		y0 \ int \ (Куб)
		cx0 \ int \ x0 + Размер/2 (Куб)
		cy0 \ int \ x0 + Размер/2 (Куб)

	Возможные действия
		Размножение => 
			Eсли ((Уровень_энергии >= (Максимальный_запас_энергии-100)) || (Уровень_энергии >= (Максимальный_запас_энергии - Желание_размножатся*100))) 
				то объект делится на два. При этом к одной рандомной характеристике каждой новой клетки прибавляется прибавляется рандомное число (-1 или 1).
		Оглядется и выбрать направление =>
			Кругозор объкта - это квадрат со стороной равной сумме размера и восприятия*2 объекта. Его центр также в (cx0; cy0). Он также является объектом вселенной.
			Перебирая коллизи объекта, находим все векторы, которые начинаются в центре кругозора и заканчиваются в центрах объектов с 
				которыми произошла коллизия( Считаем только еду, более сильных, более слабых. Остальные объекты, типа других кругозоров, не учитываем);
			Если в переборе вектор к еде - умножаем его на Голод, к сильному - умножаем его на Пугливость, к слабому - умножаем его на Агрессию.
			Суммируем все векторы по группам.
			Берем самый длинный вектор, назовем его вектор A. Этот вектор определяет приоритет клетки (Бей, Беги, Ешь).
			Считаем вектор стремления клетки V_s = A / |A|.
			
	События
		Смерть =>
			Теперь клетка ничем не отличается от еды.
		Столкновение с едой =>
			Клетка поглащает еду восстанавливая энергию.
		Затраты энергии при каждом тике =>
			Уровень_энергии -= Скорость*Размер;

	

Алгоритмы вселенной
	Обработка коллизий =>
		Фикстуры объектов вселенной - всегда прямоугольники. Для фиксации колизий нужно:
		1. Отсортировать массив объектов по координате x0. Последовательно перебираем массив.
		2. Если соблюдается условие ((объект[i+k].x0 - объект[i].x0) <= объект[i].width), то переходим к шагу 3, если 
			нет - переходим к шагу 4.
		3. Если соблюдается условие ((объект[i+k].y0 - объект[i].y0) <= объект[i].height), то фиксируем колизию, инкрементируем k, переходим к шагу 3.
		4. Инкремент i, k=1, переходим к шагу 2.

	Обработка координат клетки при следующем тике вселенной =>
		1. Отфильтровываем все коллизии объекта. Перебираем массив коллизий( Далее объект перебора О, объект с которым произошла коллизия К):
			1. Находим координаты вектора A с началом в (О.сx0; О.сy0) и концом в (К.сx0; К.сy0);
			2. Находим единичный вектор e = A / |A|. 
			3. Находим вектор с истинным расстоянием и направлением движения. v[i] = e*(К.Сила - О.Сила), если (К.Сила - О.Сила)>0, иначе вектор не учитывается.
		2. Собирали все векторы столкновений.
		3. Считаем вектор собственного перемещения клетки V_own = V_s*Скорость .
		4. Считаем вектор инерции =>
			V_en = V/3;
		5. Считаем вектор течения(рандомного направления) =>
			V_t = (random(0, 1); random(0, 1));
		6. Считаем вектор движения клетки V = v[0]+v[1] + ... v[n] + V_own + V_en + V_t.
		7. Теперь можем расчитать новые координаты клетки. =>
			(O.x0; O.y0) + V;

			






















